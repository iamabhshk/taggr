import fs from 'fs-extra';
import path from 'path';
import type { Label } from '../types.js';
import { saveMetadata, updateLabelMetadata } from './metadata.js';

const OUTPUT_DIR = './taggr';

/**
 * Convert kebab-case to camelCase
 */
function toCamelCase(str: string): string {
  if (!str || typeof str !== 'string') {
    return 'label';
  }
  // Remove any invalid characters and convert to camelCase
  return str
    .replace(/[^a-zA-Z0-9-]/g, '') // Remove invalid characters
    .replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())
    .replace(/^[A-Z]/, (match) => match.toLowerCase()); // Ensure first letter is lowercase
}

/**
 * Generate labels.json content
 */
function generateLabelsJson(labels: Label[]): string {
  const labelsObj: Record<string, string> = {};
  for (const label of labels) {
    // Validate label has required properties
    if (!label || !label.name || label.value === undefined) {
      console.warn(`Warning: Skipping invalid label: ${JSON.stringify(label)}`);
      continue;
    }
    const key = toCamelCase(label.name);
    labelsObj[key] = String(label.value); // Ensure value is a string
  }
  return JSON.stringify(labelsObj, null, 2);
}

/**
 * Generate labels.d.ts for TypeScript/JS autocomplete with enhanced metadata
 */
function generateLabelsDts(labels: Label[]): string {
  const properties = labels
    .filter(label => label && label.name) // Filter out invalid labels
    .map(label => {
      const key = toCamelCase(label.name!);
      const description = label.description || '';
      const category = label.category || 'general';
      const tags = label.tags && label.tags.length > 0 ? label.tags.join(', ') : '';
      const version = label.version || '1.0.0';
      
      // Build JSDoc comment
      let jsdoc = `  /**\n`;
      if (description) {
        jsdoc += `   * ${description.replace(/\n/g, '\n   * ')}\n`;
      }
      jsdoc += `   * @version ${version}\n`;
      jsdoc += `   * @category ${category}\n`;
      if (tags) {
        jsdoc += `   * @tags ${tags}\n`;
      }
      jsdoc += `   */\n`;
      
      return `${jsdoc}  ${key}: string;`;
    })
    .join('\n\n');

  return `// Generated by Taggr CLI - DO NOT EDIT
// Last updated: ${new Date().toISOString()}
// 
// This file provides TypeScript type definitions and autocomplete
// for your Taggr labels. Each label includes version, category, and tag information.

declare const labels: {
${properties}
};

export default labels;
`;
}

/**
 * Ensure output directory exists
 */
async function ensureOutputDir(): Promise<void> {
  try {
    await fs.ensureDir(OUTPUT_DIR);
  } catch (error: any) {
    throw new Error(`Failed to create output directory "${OUTPUT_DIR}": ${error.message}`);
  }
}

/**
 * Write a single label to labels.json (fetches all and rewrites)
 */
export async function writeLabelFile(label: Label, apiUrl?: string): Promise<string> {
  await ensureOutputDir();
  
  const jsonPath = path.join(OUTPUT_DIR, 'labels.json');
  const dtsPath = path.join(OUTPUT_DIR, 'labels.d.ts');
  
  // Read existing labels if file exists
  let existingLabels: Record<string, string> = {};
  if (await fs.pathExists(jsonPath)) {
    try {
      const content = await fs.readFile(jsonPath, 'utf-8');
      const parsed = JSON.parse(content);
      // Validate that parsed content is an object
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
        existingLabels = parsed;
      } else {
        // If file is corrupted (not an object), start fresh
        console.warn(`Warning: ${jsonPath} contains invalid data. Starting fresh.`);
      }
    } catch (error) {
      // If JSON parsing fails, start fresh
      console.warn(`Warning: Could not parse ${jsonPath}. Starting fresh.`);
    }
  }
  
  // Validate and add/update the label
  if (!label || !label.name || label.value === undefined) {
    throw new Error(`Invalid label: missing required properties (name, value)`);
  }
  const key = toCamelCase(label.name);
  existingLabels[key] = String(label.value); // Ensure value is a string
  
  // Write JSON
  try {
    await fs.writeFile(jsonPath, JSON.stringify(existingLabels, null, 2), 'utf-8');
  } catch (error: any) {
    throw new Error(`Failed to write ${jsonPath}: ${error.message}`);
  }

  // Generate d.ts from current keys
  const dtsContent = `// Generated by Taggr CLI - DO NOT EDIT
// Last updated: ${new Date().toISOString()}

declare const labels: {
${Object.keys(existingLabels).map(k => `  ${k}: string;`).join('\n')}
};

export default labels;
`;
  try {
    await fs.writeFile(dtsPath, dtsContent, 'utf-8');
  } catch (error: any) {
    throw new Error(`Failed to write ${dtsPath}: ${error.message}`);
  }

  // Update metadata for this label if apiUrl is provided
  if (apiUrl) {
    await updateLabelMetadata(label, apiUrl);
  }
  
  return jsonPath;
}

/**
 * Write all labels to labels.json and labels.d.ts
 */
export async function writeAllLabels(labels: Label[], apiUrl?: string): Promise<string[]> {
  await ensureOutputDir();
  
  const jsonPath = path.join(OUTPUT_DIR, 'labels.json');
  const dtsPath = path.join(OUTPUT_DIR, 'labels.d.ts');
  
  // Write JSON
  const jsonContent = generateLabelsJson(labels);
  try {
    await fs.writeFile(jsonPath, jsonContent, 'utf-8');
  } catch (error: any) {
    throw new Error(`Failed to write ${jsonPath}: ${error.message}`);
  }

  // Write TypeScript declarations
  const dtsContent = generateLabelsDts(labels);
  try {
    await fs.writeFile(dtsPath, dtsContent, 'utf-8');
  } catch (error: any) {
    throw new Error(`Failed to write ${dtsPath}: ${error.message}`);
  }

  // Save metadata if apiUrl is provided
  if (apiUrl) {
    await saveMetadata(labels, apiUrl);
  }
  
  return [jsonPath, dtsPath];
}

/**
 * Update labels files (alias for writeAllLabels)
 */
export async function updateIndexFile(labels: Label[], apiUrl?: string): Promise<void> {
  await writeAllLabels(labels, apiUrl);
}

/**
 * Get the output directory path
 */
export function getOutputDir(): string {
  return path.resolve(OUTPUT_DIR);
}
